# Отчет по реализации лабораторной работы: Изоляция ресурсов с помощью Docker

---

## РЕАЛИЗАЦИЯ ИЗОЛЯЦИИ РЕСУРСОВ С ПОМОЩЬЮ DOCKER

Эта глава подробно описывает процесс реализации легкого варианта лабораторной работы, сосредоточенного на изоляции ресурсов с помощью базовых команд Docker. Здесь представлены принципиальная архитектура приложения, логика его сборки и доказательства успешного запуска двух изолированных контейнеров (HTML-сайт и статический ресурс).

---

### 1.1 Установка и проверка Docker

*Docker Desktop был установлен на операционной системе macOS. Была выполнена проверка версии клиента и сервера для подтверждения корректной установки.*

**Проверена версия клиента:**

```yaml
Client: Version 28.5.1
Server: Version 28.5.1
```

---

### 1.2 Создание структуры проекта

Для обеспечения чистоты и переносимости проекта была создана следующая иерархическая структура:

```yaml
.
├── web/
│   ├── index.html
│   └── Dockerfile
└── image/
    ├── my_image.jpg
    └── Dockerfile
```

- Папка web содержала одностраничный веб-сайт (CV) на базе HTML.
- Папка image содержала изображение (my_image.jpg) для отдельного контейнера.

### 1.3 Dockerfile для веб-сайта (web/Dockerfile)

Для создания образа веб-сайта, который должен обслуживать статический HTML-контент, был использован минимальный образ nginx.

- **Использование легковесного базового образа Nginx**

`FROM nginx:alpine`

- **Копирование содержимого папки web (CV) в директорию Nginx для статических файлов**

`COPY index.html /usr/share/nginx/html/`

- **Nginx по умолчанию слушает порт 80**

`EXPOSE 80`
  
---

### 1.4 Dockerfile для изображения (image/Dockerfile)

Для статического ресурса (изображения) также был использован образ nginx, чтобы обеспечить его обслуживание по HTTP.

- **Использование легковесного базового образа Nginx**

`FROM nginx:alpine`

- **Копирование изображения в директорию Nginx для статических файлов**

`COPY my_image.jpg /usr/share/nginx/html/`

- **Изменение порта внутри контейнера на 8080 для демонстрационных целей**

`EXPOSE 8080`

---

### 1.5 Сборка образов

Сборка образов осуществлялась с присвоением тегов (my_cv и my_image) для удобства управления.

```yaml
docker build -t my_cv ./web
docker build -t my_image ./image
```

### 1.6 Запуск контейнеров

- Контейнеры были запущены в фоновом режиме (-d) с пробросом портов для внешнего доступа.
- Веб-контейнер (web_container): внутренний порт 80 проброшен на внешний порт 8080.

   `docker run -d -p 8080:80 --name web_container my_cv`
- Контейнер изображений (image_container): внутренний порт 8080 проброшен на внешний порт 8081.

   `docker run -d -p 8081:8080 --name image_container my_image`


**Доступ к изолированным ресурсам:**

- Веб-сайт CV доступен по адресу: `http://localhost:8080`
- Изображение доступно по адресу: `http://localhost:8081/my_image.jpg`

---

### 1.7 Управление контейнерами

Для управления жизненным циклом контейнеров использовались следующие команды:
- **Просмотр запущенных контейнеров:**

`docker ps`

- **Остановка:**

`docker stop web_container image_container`

- **Удаление контейнеров (после остановки):**

`docker rm web_container image_container`

- **Удаление образов:**

`docker rmi my_cv my_image`


### 1.8 Выводы

В ходе лабораторной работы были изучены основные команды Docker, необходимые для развертывания приложений: `build, run, ps, stop, rm, rmi.`

#### Было наглядно продемонстрировано:

- Как создавать образы с помощью Dockerfile для различных типов контента (веб-сайт и статические ресурсы).
- Как запускать контейнеры, обеспечивая изоляцию приложений и их ресурсов.
- Как работать с пробросом портов (-p) для доступа к изолированным сервисам через браузер.

Лабораторная работа позволила на практике увидеть ключевые преимущества контейнеризации: изоляцию приложений, быстрый запуск, переносимость и эффективное управление зависимостями.
